#!/bin/bash
#
# 

create_key(){

	mkdir -p /ddns/key
	rm -f /ddns/key/Kddns_update*
	
	local silent=( $(dnssec-keygen -K /ddns/key/ -a HMAC-MD5 -b 128 -r /dev/urandom -n USER DDNS_UPDATE) )
}

read_key(){

	KEY=$(cat /ddns/key/Kddns_update*.private | grep Key | cut -d " " -f 2)

	sed "s@DNSSEC_KEY@$KEY@g" /ddns/templates/key >> /etc/bind/named.conf.local

}

create_zone(){

	local NAMESERVER=$1
	local DYNAMIC_DOMAIN=$2

	rm -f "/etc/bind/db.$DYNAMIC_DOMAIN"
	touch "/etc/bind/db.$DYNAMIC_DOMAIN"
	chown bind:bind "/etc/bind/db.$DYNAMIC_DOMAIN"

	sed "s@NAMESERVER@$NAMESERVER@g;s@DYNAMIC_DOMAIN@$DYNAMIC_DOMAIN@g" /ddns/templates/db >> "/etc/bind/db.$DYNAMIC_DOMAIN"

	sed "s@DYNAMIC_DOMAIN@$DYNAMIC_DOMAIN@g" /ddns/templates/zone  >> /etc/bind/named.conf.local
	
}

read_config(){
	local  CONFIGFILE="$1"
	#@TODO some validation
	NAMESERVER=$(cat $CONFIGFILE | grep NAMESERVER | cut -d " " -f 2)
	DYNAMIC_DOMAIN=$(cat $CONFIGFILE | grep DYNAMIC_DOMAIN | cut -d " " -f 2)
	local my_list=("$NAMESERVER" "$DYNAMIC_DOMAIN")  
	echo "${my_list[@]}" 
}

read_configs(){	

	for filename in /ddns/config/*; do
		read_config $filename
		local result=( $(read_config $filename))

		( $(create_zone ${result[0]} ${result[1]})) 
	done

}

enable_logging(){
	cat /ddns/templates/logging >> /etc/bind/named.conf.local

	mkdir /var/log/named/
	chown bind:bind /var/log/named/
}

config_bind(){
	rm -f /etc/bind/named.conf.local

	touch /etc/bind/named.conf.local
	chown bind:bind /etc/bind/named.conf.local

	echo "// generated by samisdat/ddns" > /etc/bind/named.conf.local


	read_key
	read_configs

	#enable_logging

	# this is needed or *.jnl can not be created
	chown bind:bind /etc/bind

	service bind9 restart
}

create_client(){
	rm -f /ddns/client/*
	cp /ddns/key/Kddns_update*.private /ddns/client/samisdat-ddns-key.private
	cp /ddns/key/Kddns_update*.key /ddns/client/samisdat-ddns-key.key

	cp /ddns/templates/do-nsupdate  /ddns/client/do-nsupdate.sh
	chmod +x /ddns/client/do-nsupdate.sh

	rm -f /ddns/client/create-update-message.sh
	touch /ddns/client/create-update-message.sh

	echo "#!/bin/bash" > /ddns/client/create-update-message.sh

	for filename in /ddns/config/*; do
		read_config $filename
		local result=( $(read_config $filename))

		sed "s@NAMESERVER@$NAMESERVER@g;s@DYNAMIC_DOMAIN@$DYNAMIC_DOMAIN@g" /ddns/templates/create-update-message >> /ddns/client/create-update-message.sh

	done

	chmod +x /ddns/client/create-update-message.sh

	cd /ddns/
	tar cvf ./client.tar ./client/
	cd /ddns/server

	echo "client script created. copy from host by"
	echo "docker cp CONTAINER:/ddns/client.tar HOSTPATH"

}

SCRIPT=`basename ${BASH_SOURCE[0]}`	

#make help little nicer
#font-weight:normal
NORMAL=`tput sgr0`
#font-weight:bold
BOLD=`tput bold`

#Help function
function HELP {
cat << EOF
Supported params
-k  create update ${BOLD}k${NORMAL}ey
-z  create ${BOLD}z${NORMAL}one(s) from config(s) and restart server  
-c  create ${BOLD}c${NORMAL}lient and tar it
-h  display this ${BOLD}h${NORMAL} help, again

Usages: 

${BOLD}./$SCRIPT -k${NORMAL} # create key. Caution: This will delete eventual existing key 
${BOLD}./$SCRIPT -z${NORMAL} # read config(s) and create zones
${BOLD}./$SCRIPT -c${NORMAL} # create client script and tar it  
${BOLD}./$SCRIPT -k -z -c ${NORMAL} # 
EOF
exit 1
}

#show help if no argument
NUMARGS=$#
if [ $NUMARGS -eq 0 ]; then
  HELP
  exit 0;
fi

DO_CREATE_KEY=0
DO_CREATE_ZONE=0
DO_CREATE_CLIENT=0

while getopts kzch FLAG; do
  case $FLAG in
    k) 
      DO_CREATE_KEY=1
      ;;
    z)  
      DO_CREATE_ZONE=1
      ;;
    c)
      DO_CREATE_CLIENT=1
      ;;
    h)  
      HELP
      exit 0;      
      ;;
    \?) #unrecognized option - show help
      echo -e \\n"Unsuppoted param -${BOLD}$OPTARG${NORM} "
      HELP
      exit 0;
  esac
done

if [[ "$DO_CREATE_KEY" == 1  ]]; then
    echo "create key"
    create_key
fi

if [[ "$DO_CREATE_ZONE" == 1  ]]; then
    echo "create zone"
    config_bind
fi

if [[ "$DO_CREATE_CLIENT" == 1  ]]; then
    echo "create client"
    create_client
fi

